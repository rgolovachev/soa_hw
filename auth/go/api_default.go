/*
 * User Management API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package auth

import (
	"context"
	"crypto/md5"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"slices"
	"strconv"
	"time"

	postspb "posts/proto"
	statpb "stat/proto"

	"github.com/IBM/sarama"
	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"

	_ "github.com/lib/pq"
)

var (
	authDB            *sql.DB
	grpc_posts_conn   *grpc.ClientConn
	grpc_posts_client postspb.PostsServiceClient
	grpc_stat_conn    *grpc.ClientConn
	grpc_stat_client  statpb.StatServiceClient
)

const (
	dbConnStr        = "user=auth password=super_secret_pass dbname=auth_db host=auth_db port=5432 sslmode=disable"
	expiresDeltaSecs = 10000
)

func init() {
	var err error
	authDB, err = sql.Open("postgres", dbConnStr)
	if err != nil {
		log.Fatal(err)
	}

	grpc_posts_conn, err = grpc.Dial("dns:///posts:11777", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatal(err)
	}

	grpc_stat_conn, err = grpc.Dial("dns:///stat:11888", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatal(err)
	}

	grpc_posts_client = postspb.NewPostsServiceClient(grpc_posts_conn)
	grpc_stat_client = statpb.NewStatServiceClient(grpc_stat_conn)
}

func LoginPost(w http.ResponseWriter, r *http.Request) {
	var user_with_pass LoginBody
	if err := json.NewDecoder(r.Body).Decode(&user_with_pass); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Failed to decode JSON")
		return
	}
	if user_with_pass.Username == "" || user_with_pass.Password == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "There is no username or password field in JSON, or one of them (or both) is empty")
		return
	}

	tx, err := authDB.Begin()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}
	defer tx.Rollback()

	true_pass_md5_sum := make([]byte, 16)
	err = tx.QueryRow("SELECT password_hash FROM users WHERE username = $1", user_with_pass.Username).Scan(&true_pass_md5_sum)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	cur_pass_md5_sum := md5.Sum([]byte(user_with_pass.Password))
	if slices.Compare(true_pass_md5_sum, cur_pass_md5_sum[:]) != 0 {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintln(w, "There is no such user or password is wrong")
		return
	}

	// check if there is an existing session (and return it if it exists)
	var token string
	var created time.Time
	err = tx.QueryRow("SELECT token, created FROM user_sessions WHERE username = $1", user_with_pass.Username).Scan(&token, &created)
	if err != nil && err != sql.ErrNoRows {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	if err == nil && time.Since(created).Seconds() < expiresDeltaSecs {
		err = tx.Commit()
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, err)
			return
		}

		w.Header().Add("Set-Cookie", token)
		fmt.Fprintln(w, "User has been logined successfully")
		return
	}

	cur_token := uuid.New().String()
	cur_created := time.Now()

	if err == nil {
		_, err = tx.Exec("UPDATE user_sessions SET token = $2, created = $3 WHERE username = $1", user_with_pass.Username, cur_token, cur_created)
	} else {
		_, err = tx.Exec("INSERT INTO user_sessions (username, token, created) VALUES ($1, $2, $3)", user_with_pass.Username, cur_token, cur_created)
	}

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	err = tx.Commit()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	w.Header().Add("Set-Cookie", cur_token)
	fmt.Fprintln(w, "User has been logined successfully")
}

func RegisterPost(w http.ResponseWriter, r *http.Request) {
	var user_with_pass RegisterBody
	if err := json.NewDecoder(r.Body).Decode(&user_with_pass); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Failed to decode JSON")
		return
	}
	if user_with_pass.Username == "" || user_with_pass.Password == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "There is no username or password field in JSON, or one of them (or both) is empty")
		return
	}

	tx, err := authDB.Begin()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}
	defer tx.Rollback()

	count := 0
	tx.QueryRow("SELECT COUNT(*) FROM users WHERE username = $1", user_with_pass.Username).Scan(&count)
	if count > 0 {
		w.WriteHeader(http.StatusConflict)
		fmt.Fprintln(w, "User with this name already registered")
		return
	}

	pass_md5_sum := md5.Sum([]byte(user_with_pass.Password))
	_, err = tx.Exec("INSERT INTO users (username, password_hash) VALUES ($1, $2)", user_with_pass.Username, pass_md5_sum[:])
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	_, err = tx.Exec("INSERT INTO user_data (username) VALUES ($1)", user_with_pass.Username)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	err = tx.Commit()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	fmt.Fprintln(w, "User has been registered")
}

func UpdatePut(w http.ResponseWriter, r *http.Request) {
	var user_updates UpdateBody
	if err := json.NewDecoder(r.Body).Decode(&user_updates); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Failed to decode JSON")
		return
	}

	token := r.Header.Get("Cookie")
	if token == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "User must specify Cookie header")
		return
	}

	tx, err := authDB.Begin()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}
	defer tx.Rollback()

	var username string
	var created time.Time
	err = tx.QueryRow("SELECT username, created FROM user_sessions WHERE token = $1", token).Scan(&username, &created)
	if err != nil || time.Since(created).Seconds() >= expiresDeltaSecs {
		w.WriteHeader(http.StatusForbidden)
		fmt.Fprintln(w, "Cookie is invalid")
		return
	}

	// just bruteforce JSON and evaluate UPDATE query
	// UPDATE user_data SET firstname = $2, lastname = $3, ... WHERE username = $1
	set_stmt := ""
	seqnum := 2
	fl := false
	params := make([]interface{}, 0)
	params = append(params, username)
	if user_updates.FirstName != "" {
		set_stmt += fmt.Sprintf("firstname = $%d", seqnum)
		seqnum++
		fl = true
		params = append(params, user_updates.FirstName)
	}
	if user_updates.LastName != "" {
		if !fl {
			set_stmt += fmt.Sprintf("lastname = $%d", seqnum)
		} else {
			set_stmt += fmt.Sprintf(", lastname = $%d", seqnum)
		}
		seqnum++
		fl = true
		params = append(params, user_updates.LastName)
	}
	if user_updates.BirthDate != "" {
		if !fl {
			set_stmt += fmt.Sprintf("birthdate = $%d", seqnum)
		} else {
			set_stmt += fmt.Sprintf(", birthdate = $%d", seqnum)
		}
		seqnum++
		fl = true
		params = append(params, user_updates.BirthDate)
	}
	if user_updates.Email != "" {
		if !fl {
			set_stmt += fmt.Sprintf("email = $%d", seqnum)
		} else {
			set_stmt += fmt.Sprintf(", email = $%d", seqnum)
		}
		seqnum++
		fl = true
		params = append(params, user_updates.Email)
	}
	if user_updates.Telephone != "" {
		if !fl {
			set_stmt += fmt.Sprintf("telephone = $%d", seqnum)
		} else {
			set_stmt += fmt.Sprintf(", telephone = $%d", seqnum)
		}
		seqnum++
		fl = true
		params = append(params, user_updates.Telephone)
	}

	_, err = tx.Exec("UPDATE user_data SET "+set_stmt+" WHERE username = $1", params...)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	err = tx.Commit()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	fmt.Fprintln(w, "Data was updated")
}

func GetUsername(w http.ResponseWriter, r *http.Request) (string, error) {
	token := r.Header.Get("Cookie")
	if token == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "User must specify Cookie header")
		return "", errors.New("")
	}

	var username string
	var created time.Time
	err := authDB.QueryRow("SELECT username, created FROM user_sessions WHERE token = $1", token).Scan(&username, &created)
	if err != nil || time.Since(created).Seconds() >= expiresDeltaSecs {
		w.WriteHeader(http.StatusForbidden)
		fmt.Fprintln(w, "Cookie is invalid")
		return "", errors.New("")
	}

	return username, nil
}

func GetUserID(w http.ResponseWriter, r *http.Request, username string) (uint64, error) {
	var id uint64
	err := authDB.QueryRow("SELECT id FROM users WHERE username = $1", username).Scan(&id)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, err)
		return 0, nil
	}

	return id, nil
}

func GetUsernameByUserID(w http.ResponseWriter, r *http.Request, userId uint64) (string, error) {
	var username string
	err := authDB.QueryRow("SELECT username FROM users WHERE id = $1", userId).Scan(&username)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return "", nil
	}

	return username, nil
}

func CreatePostPost(w http.ResponseWriter, r *http.Request) {
	var body CreatePostBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Failed to decode JSON")
		return
	}

	username, err := GetUsername(w, r)
	if err != nil {
		return
	}
	userID, err := GetUserID(w, r, username)
	if err != nil {
		return
	}

	grpc_resp, err := grpc_posts_client.CreatePost(context.Background(), &postspb.CreatePostReq{UserId: userID, Text: body.Text})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	http_resp := CreatePostResponse{PostId: grpc_resp.PostId}
	http_resp_bytes, err := json.Marshal(http_resp)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	fmt.Fprintln(w, string(http_resp_bytes))
}

func DeletePostPostIdDelete(w http.ResponseWriter, r *http.Request) {
	username, err := GetUsername(w, r)
	if err != nil {
		return
	}
	userID, err := GetUserID(w, r, username)
	if err != nil {
		return
	}

	post_id := mux.Vars(r)["post_id"]
	_, err = grpc_posts_client.DeletePost(context.Background(), &postspb.DeletePostReq{UserId: userID, PostId: post_id})
	if err != nil {
		if status.Code(err) == codes.NotFound {
			w.WriteHeader(http.StatusNotFound)
			fmt.Fprintln(w, "There is no such user with this post_id")
		} else {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		}
		return
	}
	fmt.Fprintln(w, "Post has been deleted succesfully")
}

func GetPostPostIdGet(w http.ResponseWriter, r *http.Request) {
	_, err := GetUsername(w, r)
	if err != nil {
		return
	}

	post_id := mux.Vars(r)["post_id"]
	grpc_resp, err := grpc_posts_client.GetPost(context.Background(), &postspb.GetPostReq{PostId: post_id})
	if err != nil {
		if status.Code(err) == codes.NotFound {
			w.WriteHeader(http.StatusNotFound)
			fmt.Fprintln(w, "There is no such user with this post_id")
		} else {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		}
		return
	}

	fmt.Fprintln(w, grpc_resp.Text)
}

func GetPostsUsernameGet(w http.ResponseWriter, r *http.Request) {
	_, err := GetUsername(w, r)
	if err != nil {
		return
	}

	posts_author := mux.Vars(r)["username"]
	from_str, count_str := r.Header.Get("From"), r.Header.Get("Count")
	if len(from_str) == 0 || len(count_str) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "User must specify From and Count headers properly")
		return
	}

	from, err := strconv.ParseUint(from_str, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "User must specify From and Count headers properly")
		return
	}

	count, err := strconv.ParseUint(count_str, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "User must specify From and Count headers properly")
		return
	}

	userID, err := GetUserID(w, r, posts_author)
	if err != nil {
		return
	}

	resp, err := grpc_posts_client.GetAllPosts(context.Background(), &postspb.GetAllPostsReq{UserId: userID, From: from, Count: count})
	if err != nil || len(resp.PostIds) != len(resp.Texts) {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	for i := 0; i < len(resp.PostIds); i++ {
		fmt.Fprintf(w, "Post #%d with post_id %s:\n", i, resp.PostIds[i])
		fmt.Fprintf(w, "%s\n\n", resp.Texts[i])
	}
}

type Message struct {
	PostID string `json:"post_id"`
	UserID uint64 `json:"user_id"`
}

type IncEventType uint8

const (
	LikeEvent IncEventType = iota
	ViewEvent
)

func IncEvent(w http.ResponseWriter, r *http.Request, eventType IncEventType) {
	username, err := GetUsername(w, r)
	if err != nil {
		return
	}
	userID, err := GetUserID(w, r, username)
	if err != nil {
		return
	}

	postID := mux.Vars(r)["post_id"]

	brokers := []string{os.Getenv("KAFKA_BROKER")}

	var topic string
	if eventType == LikeEvent {
		topic = "likes"
	} else {
		topic = "views"
	}

	config := sarama.NewConfig()
	config.Producer.Return.Successes = true
	producer, err := sarama.NewSyncProducer(brokers, config)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}
	defer producer.Close()

	msg := Message{
		PostID: postID,
		UserID: userID,
	}
	msgBytes, err := json.Marshal(msg)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	msgToSend := &sarama.ProducerMessage{
		Topic: topic,
		Key:   sarama.StringEncoder(msg.PostID),
		Value: sarama.ByteEncoder(msgBytes),
	}

	_, _, err = producer.SendMessage(msgToSend)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, err)
		return
	}

	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "Message was sent successfuly")
}

func LikePostPostIdPost(w http.ResponseWriter, r *http.Request) {
	IncEvent(w, r, LikeEvent)
}

func ViewPostPostIdPost(w http.ResponseWriter, r *http.Request) {
	IncEvent(w, r, ViewEvent)
}

func UpdatePostPostIdPut(w http.ResponseWriter, r *http.Request) {
	var body UpdatePostPostIdBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Failed to decode JSON")
		return
	}

	username, err := GetUsername(w, r)
	if err != nil {
		return
	}
	userID, err := GetUserID(w, r, username)
	if err != nil {
		return
	}

	post_id := mux.Vars(r)["post_id"]
	_, err = grpc_posts_client.UpdatePost(context.Background(), &postspb.UpdatePostReq{UserId: userID, Text: body.Text, PostId: post_id})
	if err != nil {
		if status.Code(err) == codes.NotFound {
			w.WriteHeader(http.StatusNotFound)
			fmt.Fprintln(w, "There is no such user with this post_id")
		} else {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		}
		return
	}

	fmt.Fprintln(w, "Post has been updated succesfully")
}

func PostStatsPostIdGet(w http.ResponseWriter, r *http.Request) {
	_, err := GetUsername(w, r)
	if err != nil {
		return
	}

	post_id := mux.Vars(r)["post_id"]
	post, err := grpc_posts_client.CheckIfPostExists(context.Background(), &postspb.CheckIfPostExistsReq{PostId: post_id})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}
	if !post.Exists {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintln(w, "Post not found")
		return
	}

	stats, err := grpc_stat_client.GetPostStats(context.Background(), &statpb.GetPostStatsReq{PostId: post_id})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	resp := PostStatsResponse{
		PostId: post_id,
		Likes:  stats.Likes,
		Views:  stats.Views,
	}
	resp_bytes, err := json.Marshal(resp)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	fmt.Fprintln(w, string(resp_bytes))
}

func TopPostsSortByGet(w http.ResponseWriter, r *http.Request) {
	_, err := GetUsername(w, r)
	if err != nil {
		return
	}

	sort_by := mux.Vars(r)["sort_by"]
	if sort_by != "likes" && sort_by != "views" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "sort_by parameter is invalid")
		return
	}

	var top *statpb.GetTopPostsResp
	if sort_by == "likes" {
		top, err = grpc_stat_client.GetTopPosts(context.Background(), &statpb.GetTopPostsReq{SortBy: statpb.Metric_Likes})
	} else {
		top, err = grpc_stat_client.GetTopPosts(context.Background(), &statpb.GetTopPostsReq{SortBy: statpb.Metric_Views})
	}
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	resp := TopPostsResponse{
		PostIds: top.PostId,
		Values:  top.Value,
	}
	resp_bytes, err := json.Marshal(resp)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	fmt.Fprintln(w, string(resp_bytes))
}

func TopUsersGet(w http.ResponseWriter, r *http.Request) {
	_, err := GetUsername(w, r)
	if err != nil {
		return
	}

	top, err := grpc_stat_client.GetTopUsers(context.Background(), &statpb.GetTopUsersReq{})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	usernames := make([]string, 0)
	for _, authorId := range top.AuthorId {
		curUsername, err := GetUsernameByUserID(w, r, authorId)
		if err != nil {
			return
		}

		usernames = append(usernames, curUsername)
	}

	resp := TopUsersResponse{
		Usernames: usernames,
		Likes:     top.Likes,
	}
	resp_bytes, err := json.Marshal(resp)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Some internal error (with postgres, for example)")
		return
	}

	fmt.Fprintln(w, string(resp_bytes))
}
